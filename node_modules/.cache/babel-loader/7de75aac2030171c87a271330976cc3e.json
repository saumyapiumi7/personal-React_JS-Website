{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\User\\\\WebstormProjects\\\\personal-React_JS-Website\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\User\\\\WebstormProjects\\\\personal-React_JS-Website\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CanvasUtils = void 0;\n\nvar ColorUtils_1 = require(\"./ColorUtils\");\n\nvar Utils_1 = require(\"./Utils\");\n\nvar CanvasUtils = /*#__PURE__*/function () {\n  function CanvasUtils() {\n    _classCallCheck(this, CanvasUtils);\n  }\n\n  _createClass(CanvasUtils, null, [{\n    key: \"paintBase\",\n    value: function paintBase(context, dimension, baseColor) {\n      context.save();\n      context.fillStyle = baseColor !== null && baseColor !== void 0 ? baseColor : \"rgba(0,0,0,0)\";\n      context.fillRect(0, 0, dimension.width, dimension.height);\n      context.restore();\n    }\n  }, {\n    key: \"clear\",\n    value: function clear(context, dimension) {\n      context.clearRect(0, 0, dimension.width, dimension.height);\n    }\n  }, {\n    key: \"drawLinkLine\",\n    value: function drawLinkLine(context, width, begin, end, maxDistance, canvasSize, warp, backgroundMask, colorLine, opacity, shadow) {\n      var drawn = false;\n\n      if (Utils_1.Utils.getDistance(begin, end) <= maxDistance) {\n        this.drawLine(context, begin, end);\n        drawn = true;\n      } else if (warp) {\n        var pi1;\n        var pi2;\n        var endNE = {\n          x: end.x - canvasSize.width,\n          y: end.y\n        };\n\n        var _Utils_1$Utils$getDis = Utils_1.Utils.getDistances(begin, endNE),\n            dx = _Utils_1$Utils$getDis.dx,\n            dy = _Utils_1$Utils$getDis.dy,\n            distance = _Utils_1$Utils$getDis.distance;\n\n        if (distance <= maxDistance) {\n          var yi = begin.y - dy / dx * begin.x;\n          pi1 = {\n            x: 0,\n            y: yi\n          };\n          pi2 = {\n            x: canvasSize.width,\n            y: yi\n          };\n        } else {\n          var endSW = {\n            x: end.x,\n            y: end.y - canvasSize.height\n          };\n\n          var _Utils_1$Utils$getDis2 = Utils_1.Utils.getDistances(begin, endSW),\n              _dx = _Utils_1$Utils$getDis2.dx,\n              _dy = _Utils_1$Utils$getDis2.dy,\n              _distance = _Utils_1$Utils$getDis2.distance;\n\n          if (_distance <= maxDistance) {\n            var _yi = begin.y - _dy / _dx * begin.x;\n\n            var xi = -_yi / (_dy / _dx);\n            pi1 = {\n              x: xi,\n              y: 0\n            };\n            pi2 = {\n              x: xi,\n              y: canvasSize.height\n            };\n          } else {\n            var endSE = {\n              x: end.x - canvasSize.width,\n              y: end.y - canvasSize.height\n            };\n\n            var _Utils_1$Utils$getDis3 = Utils_1.Utils.getDistances(begin, endSE),\n                _dx2 = _Utils_1$Utils$getDis3.dx,\n                _dy2 = _Utils_1$Utils$getDis3.dy,\n                _distance2 = _Utils_1$Utils$getDis3.distance;\n\n            if (_distance2 <= maxDistance) {\n              var _yi2 = begin.y - _dy2 / _dx2 * begin.x;\n\n              var _xi = -_yi2 / (_dy2 / _dx2);\n\n              pi1 = {\n                x: _xi,\n                y: _yi2\n              };\n              pi2 = {\n                x: pi1.x + canvasSize.width,\n                y: pi1.y + canvasSize.height\n              };\n            }\n          }\n        }\n\n        if (pi1 && pi2) {\n          this.drawLine(context, begin, pi1);\n          this.drawLine(context, end, pi2);\n          drawn = true;\n        }\n      }\n\n      if (!drawn) {\n        return;\n      }\n\n      context.lineWidth = width;\n\n      if (backgroundMask) {\n        context.globalCompositeOperation = \"destination-out\";\n      }\n\n      context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);\n\n      if (shadow.enable) {\n        var shadowColor = ColorUtils_1.ColorUtils.colorToRgb(shadow.color);\n\n        if (shadowColor) {\n          context.shadowBlur = shadow.blur;\n          context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);\n        }\n      }\n\n      context.stroke();\n    }\n  }, {\n    key: \"drawLinkTriangle\",\n    value: function drawLinkTriangle(context, width, pos1, pos2, pos3, backgroundMask, colorTriangle, opacityTriangle) {\n      this.drawTriangle(context, pos1, pos2, pos3);\n      context.lineWidth = width;\n\n      if (backgroundMask) {\n        context.globalCompositeOperation = \"destination-out\";\n      }\n\n      context.fillStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorTriangle, opacityTriangle);\n      context.fill();\n    }\n  }, {\n    key: \"drawConnectLine\",\n    value: function drawConnectLine(context, width, lineStyle, begin, end) {\n      context.save();\n      this.drawLine(context, begin, end);\n      context.lineWidth = width;\n      context.strokeStyle = lineStyle;\n      context.stroke();\n      context.restore();\n    }\n  }, {\n    key: \"gradient\",\n    value: function gradient(context, p1, p2, opacity) {\n      var gradStop = Math.floor(p2.size.value / p1.size.value);\n      var color1 = p1.getColor();\n      var color2 = p2.getColor();\n\n      if (!color1 || !color2) {\n        return;\n      }\n\n      var sourcePos = p1.getPosition();\n      var destPos = p2.getPosition();\n      var midRgb = ColorUtils_1.ColorUtils.mix(color1, color2, p1.size.value, p2.size.value);\n      var grad = context.createLinearGradient(sourcePos.x, sourcePos.y, destPos.x, destPos.y);\n      grad.addColorStop(0, ColorUtils_1.ColorUtils.getStyleFromHsl(color1, opacity));\n      grad.addColorStop(gradStop > 1 ? 1 : gradStop, ColorUtils_1.ColorUtils.getStyleFromRgb(midRgb, opacity));\n      grad.addColorStop(1, ColorUtils_1.ColorUtils.getStyleFromHsl(color2, opacity));\n      return grad;\n    }\n  }, {\n    key: \"drawGrabLine\",\n    value: function drawGrabLine(context, width, begin, end, colorLine, opacity) {\n      context.save();\n      this.drawLine(context, begin, end);\n      context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);\n      context.lineWidth = width;\n      context.stroke();\n      context.restore();\n    }\n  }, {\n    key: \"drawParticle\",\n    value: function drawParticle(container, context, particle, delta, colorValue, backgroundMask, radius, opacity, shadow) {\n      var pos = particle.getPosition();\n      context.save();\n      context.translate(pos.x, pos.y);\n      context.beginPath();\n\n      if (particle.angle !== 0) {\n        context.rotate(particle.angle * Math.PI / 180);\n      }\n\n      if (backgroundMask) {\n        context.globalCompositeOperation = \"destination-out\";\n      }\n\n      var shadowColor = particle.shadowColor;\n\n      if (shadow.enable && shadowColor) {\n        context.shadowBlur = shadow.blur;\n        context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);\n        context.shadowOffsetX = shadow.offset.x;\n        context.shadowOffsetY = shadow.offset.y;\n      }\n\n      context.fillStyle = colorValue;\n      var stroke = particle.stroke;\n      context.lineWidth = stroke.width;\n\n      if (particle.strokeColor) {\n        context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(particle.strokeColor, particle.stroke.opacity);\n      }\n\n      if (particle.close) {\n        context.closePath();\n      }\n\n      this.drawShape(container, context, particle, radius, opacity, delta);\n\n      if (stroke.width > 0 && particle.strokeColor) {\n        context.stroke();\n      }\n\n      if (particle.fill) {\n        context.fill();\n      }\n\n      context.restore();\n      context.save();\n      context.translate(pos.x, pos.y);\n\n      if (particle.angle !== 0) {\n        context.rotate(particle.angle * Math.PI / 180);\n      }\n\n      if (backgroundMask) {\n        context.globalCompositeOperation = \"destination-out\";\n      }\n\n      this.drawShapeAfterEffect(container, context, particle, radius, opacity, delta);\n      context.restore();\n    }\n  }, {\n    key: \"drawShape\",\n    value: function drawShape(container, context, particle, radius, opacity, delta) {\n      if (!particle.shape) {\n        return;\n      }\n\n      var drawer = container.drawers.get(particle.shape);\n\n      if (!drawer) {\n        return;\n      }\n\n      drawer.draw(context, particle, radius, opacity, delta);\n    }\n  }, {\n    key: \"drawShapeAfterEffect\",\n    value: function drawShapeAfterEffect(container, context, particle, radius, opacity, delta) {\n      if (!particle.shape) {\n        return;\n      }\n\n      var drawer = container.drawers.get(particle.shape);\n\n      if (!(drawer === null || drawer === void 0 ? void 0 : drawer.afterEffect)) {\n        return;\n      }\n\n      drawer.afterEffect(context, particle, radius, opacity, delta);\n    }\n  }, {\n    key: \"drawPlugin\",\n    value: function drawPlugin(context, plugin, delta) {\n      if (plugin.draw !== undefined) {\n        context.save();\n        plugin.draw(context, delta);\n        context.restore();\n      }\n    }\n  }, {\n    key: \"drawLine\",\n    value: function drawLine(context, begin, end) {\n      context.beginPath();\n      context.moveTo(begin.x, begin.y);\n      context.lineTo(end.x, end.y);\n      context.closePath();\n    }\n  }, {\n    key: \"drawTriangle\",\n    value: function drawTriangle(context, p1, p2, p3) {\n      context.beginPath();\n      context.moveTo(p1.x, p1.y);\n      context.lineTo(p2.x, p2.y);\n      context.lineTo(p3.x, p3.y);\n      context.closePath();\n    }\n  }]);\n\n  return CanvasUtils;\n}();\n\nexports.CanvasUtils = CanvasUtils;","map":{"version":3,"sources":["C:/Users/User/WebstormProjects/personal-React_JS-Website/node_modules/tsparticles/dist/Utils/CanvasUtils.js"],"names":["Object","defineProperty","exports","value","CanvasUtils","ColorUtils_1","require","Utils_1","context","dimension","baseColor","save","fillStyle","fillRect","width","height","restore","clearRect","begin","end","maxDistance","canvasSize","warp","backgroundMask","colorLine","opacity","shadow","drawn","Utils","getDistance","drawLine","pi1","pi2","endNE","x","y","getDistances","dx","dy","distance","yi","endSW","xi","endSE","lineWidth","globalCompositeOperation","strokeStyle","ColorUtils","getStyleFromRgb","enable","shadowColor","colorToRgb","color","shadowBlur","blur","stroke","pos1","pos2","pos3","colorTriangle","opacityTriangle","drawTriangle","fill","lineStyle","p1","p2","gradStop","Math","floor","size","color1","getColor","color2","sourcePos","getPosition","destPos","midRgb","mix","grad","createLinearGradient","addColorStop","getStyleFromHsl","container","particle","delta","colorValue","radius","pos","translate","beginPath","angle","rotate","PI","shadowOffsetX","offset","shadowOffsetY","strokeColor","close","closePath","drawShape","drawShapeAfterEffect","shape","drawer","drawers","get","draw","afterEffect","plugin","undefined","moveTo","lineTo","p3"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CanvasUtils = void 0;\nconst ColorUtils_1 = require(\"./ColorUtils\");\nconst Utils_1 = require(\"./Utils\");\nclass CanvasUtils {\n    static paintBase(context, dimension, baseColor) {\n        context.save();\n        context.fillStyle = baseColor !== null && baseColor !== void 0 ? baseColor : \"rgba(0,0,0,0)\";\n        context.fillRect(0, 0, dimension.width, dimension.height);\n        context.restore();\n    }\n    static clear(context, dimension) {\n        context.clearRect(0, 0, dimension.width, dimension.height);\n    }\n    static drawLinkLine(context, width, begin, end, maxDistance, canvasSize, warp, backgroundMask, colorLine, opacity, shadow) {\n        let drawn = false;\n        if (Utils_1.Utils.getDistance(begin, end) <= maxDistance) {\n            this.drawLine(context, begin, end);\n            drawn = true;\n        }\n        else if (warp) {\n            let pi1;\n            let pi2;\n            const endNE = {\n                x: end.x - canvasSize.width,\n                y: end.y,\n            };\n            const { dx, dy, distance } = Utils_1.Utils.getDistances(begin, endNE);\n            if (distance <= maxDistance) {\n                const yi = begin.y - (dy / dx) * begin.x;\n                pi1 = { x: 0, y: yi };\n                pi2 = { x: canvasSize.width, y: yi };\n            }\n            else {\n                const endSW = {\n                    x: end.x,\n                    y: end.y - canvasSize.height,\n                };\n                const { dx, dy, distance } = Utils_1.Utils.getDistances(begin, endSW);\n                if (distance <= maxDistance) {\n                    const yi = begin.y - (dy / dx) * begin.x;\n                    const xi = -yi / (dy / dx);\n                    pi1 = { x: xi, y: 0 };\n                    pi2 = { x: xi, y: canvasSize.height };\n                }\n                else {\n                    const endSE = {\n                        x: end.x - canvasSize.width,\n                        y: end.y - canvasSize.height,\n                    };\n                    const { dx, dy, distance } = Utils_1.Utils.getDistances(begin, endSE);\n                    if (distance <= maxDistance) {\n                        const yi = begin.y - (dy / dx) * begin.x;\n                        const xi = -yi / (dy / dx);\n                        pi1 = { x: xi, y: yi };\n                        pi2 = { x: pi1.x + canvasSize.width, y: pi1.y + canvasSize.height };\n                    }\n                }\n            }\n            if (pi1 && pi2) {\n                this.drawLine(context, begin, pi1);\n                this.drawLine(context, end, pi2);\n                drawn = true;\n            }\n        }\n        if (!drawn) {\n            return;\n        }\n        context.lineWidth = width;\n        if (backgroundMask) {\n            context.globalCompositeOperation = \"destination-out\";\n        }\n        context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);\n        if (shadow.enable) {\n            const shadowColor = ColorUtils_1.ColorUtils.colorToRgb(shadow.color);\n            if (shadowColor) {\n                context.shadowBlur = shadow.blur;\n                context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);\n            }\n        }\n        context.stroke();\n    }\n    static drawLinkTriangle(context, width, pos1, pos2, pos3, backgroundMask, colorTriangle, opacityTriangle) {\n        this.drawTriangle(context, pos1, pos2, pos3);\n        context.lineWidth = width;\n        if (backgroundMask) {\n            context.globalCompositeOperation = \"destination-out\";\n        }\n        context.fillStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorTriangle, opacityTriangle);\n        context.fill();\n    }\n    static drawConnectLine(context, width, lineStyle, begin, end) {\n        context.save();\n        this.drawLine(context, begin, end);\n        context.lineWidth = width;\n        context.strokeStyle = lineStyle;\n        context.stroke();\n        context.restore();\n    }\n    static gradient(context, p1, p2, opacity) {\n        const gradStop = Math.floor(p2.size.value / p1.size.value);\n        const color1 = p1.getColor();\n        const color2 = p2.getColor();\n        if (!color1 || !color2) {\n            return;\n        }\n        const sourcePos = p1.getPosition();\n        const destPos = p2.getPosition();\n        const midRgb = ColorUtils_1.ColorUtils.mix(color1, color2, p1.size.value, p2.size.value);\n        const grad = context.createLinearGradient(sourcePos.x, sourcePos.y, destPos.x, destPos.y);\n        grad.addColorStop(0, ColorUtils_1.ColorUtils.getStyleFromHsl(color1, opacity));\n        grad.addColorStop(gradStop > 1 ? 1 : gradStop, ColorUtils_1.ColorUtils.getStyleFromRgb(midRgb, opacity));\n        grad.addColorStop(1, ColorUtils_1.ColorUtils.getStyleFromHsl(color2, opacity));\n        return grad;\n    }\n    static drawGrabLine(context, width, begin, end, colorLine, opacity) {\n        context.save();\n        this.drawLine(context, begin, end);\n        context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(colorLine, opacity);\n        context.lineWidth = width;\n        context.stroke();\n        context.restore();\n    }\n    static drawParticle(container, context, particle, delta, colorValue, backgroundMask, radius, opacity, shadow) {\n        const pos = particle.getPosition();\n        context.save();\n        context.translate(pos.x, pos.y);\n        context.beginPath();\n        if (particle.angle !== 0) {\n            context.rotate((particle.angle * Math.PI) / 180);\n        }\n        if (backgroundMask) {\n            context.globalCompositeOperation = \"destination-out\";\n        }\n        const shadowColor = particle.shadowColor;\n        if (shadow.enable && shadowColor) {\n            context.shadowBlur = shadow.blur;\n            context.shadowColor = ColorUtils_1.ColorUtils.getStyleFromRgb(shadowColor);\n            context.shadowOffsetX = shadow.offset.x;\n            context.shadowOffsetY = shadow.offset.y;\n        }\n        context.fillStyle = colorValue;\n        const stroke = particle.stroke;\n        context.lineWidth = stroke.width;\n        if (particle.strokeColor) {\n            context.strokeStyle = ColorUtils_1.ColorUtils.getStyleFromRgb(particle.strokeColor, particle.stroke.opacity);\n        }\n        if (particle.close) {\n            context.closePath();\n        }\n        this.drawShape(container, context, particle, radius, opacity, delta);\n        if (stroke.width > 0 && particle.strokeColor) {\n            context.stroke();\n        }\n        if (particle.fill) {\n            context.fill();\n        }\n        context.restore();\n        context.save();\n        context.translate(pos.x, pos.y);\n        if (particle.angle !== 0) {\n            context.rotate((particle.angle * Math.PI) / 180);\n        }\n        if (backgroundMask) {\n            context.globalCompositeOperation = \"destination-out\";\n        }\n        this.drawShapeAfterEffect(container, context, particle, radius, opacity, delta);\n        context.restore();\n    }\n    static drawShape(container, context, particle, radius, opacity, delta) {\n        if (!particle.shape) {\n            return;\n        }\n        const drawer = container.drawers.get(particle.shape);\n        if (!drawer) {\n            return;\n        }\n        drawer.draw(context, particle, radius, opacity, delta);\n    }\n    static drawShapeAfterEffect(container, context, particle, radius, opacity, delta) {\n        if (!particle.shape) {\n            return;\n        }\n        const drawer = container.drawers.get(particle.shape);\n        if (!(drawer === null || drawer === void 0 ? void 0 : drawer.afterEffect)) {\n            return;\n        }\n        drawer.afterEffect(context, particle, radius, opacity, delta);\n    }\n    static drawPlugin(context, plugin, delta) {\n        if (plugin.draw !== undefined) {\n            context.save();\n            plugin.draw(context, delta);\n            context.restore();\n        }\n    }\n    static drawLine(context, begin, end) {\n        context.beginPath();\n        context.moveTo(begin.x, begin.y);\n        context.lineTo(end.x, end.y);\n        context.closePath();\n    }\n    static drawTriangle(context, p1, p2, p3) {\n        context.beginPath();\n        context.moveTo(p1.x, p1.y);\n        context.lineTo(p2.x, p2.y);\n        context.lineTo(p3.x, p3.y);\n        context.closePath();\n    }\n}\nexports.CanvasUtils = CanvasUtils;\n"]},"metadata":{},"sourceType":"script"}