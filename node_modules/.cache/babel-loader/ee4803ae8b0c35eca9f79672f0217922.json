{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\User\\\\WebstormProjects\\\\personal-React_JS-Website\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"C:\\\\Users\\\\User\\\\WebstormProjects\\\\personal-React_JS-Website\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\User\\\\WebstormProjects\\\\personal-React_JS-Website\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\User\\\\WebstormProjects\\\\personal-React_JS-Website\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Updater = void 0;\n\nvar Utils_1 = require(\"../../Utils\");\n\nvar Mover_1 = require(\"./Mover\");\n\nvar Enums_1 = require(\"../../Enums\");\n\nvar Updater = /*#__PURE__*/function () {\n  function Updater(container, particle) {\n    _classCallCheck(this, Updater);\n\n    this.container = container;\n    this.particle = particle;\n    this.mover = new Mover_1.Mover(container, particle);\n  }\n\n  _createClass(Updater, [{\n    key: \"update\",\n    value: function update(delta) {\n      this.mover.move(delta);\n      this.updateOpacity(delta);\n      this.updateSize(delta);\n      this.updateAngle(delta);\n      this.updateColor(delta);\n      this.fixOutOfCanvasPosition();\n      this.updateOutMode(delta);\n    }\n  }, {\n    key: \"updateOpacity\",\n    value: function updateOpacity(delta) {\n      var options = this.container.options;\n      var particle = this.particle;\n      var deltaFactor = options.fpsLimit > 0 ? 60 * delta / 1000 : 3.6;\n\n      if (particle.particlesOptions.opacity.animation.enable) {\n        switch (particle.opacity.status) {\n          case Enums_1.OpacityAnimationStatus.increasing:\n            if (particle.opacity.value >= particle.particlesOptions.opacity.value) {\n              particle.opacity.status = Enums_1.OpacityAnimationStatus.decreasing;\n            } else {\n              particle.opacity.value += (particle.opacity.velocity || 0) * deltaFactor;\n            }\n\n            break;\n\n          case Enums_1.OpacityAnimationStatus.decreasing:\n            if (particle.opacity.value <= particle.particlesOptions.opacity.animation.minimumValue) {\n              particle.opacity.status = Enums_1.OpacityAnimationStatus.increasing;\n            } else {\n              particle.opacity.value -= (particle.opacity.velocity || 0) * deltaFactor;\n            }\n\n            break;\n        }\n\n        if (particle.opacity.value < 0) {\n          particle.opacity.value = 0;\n        }\n      }\n    }\n  }, {\n    key: \"updateSize\",\n    value: function updateSize(delta) {\n      var _a;\n\n      var container = this.container;\n      var options = container.options;\n      var particle = this.particle;\n      var deltaFactor = options.fpsLimit > 0 ? 60 * delta / 1000 : 3.6;\n      var sizeOpt = particle.particlesOptions.size;\n      var sizeAnim = sizeOpt.animation;\n\n      if (sizeAnim.enable) {\n        switch (particle.size.status) {\n          case Enums_1.SizeAnimationStatus.increasing:\n            if (particle.size.value >= ((_a = particle.sizeValue) !== null && _a !== void 0 ? _a : container.retina.sizeValue)) {\n              particle.size.status = Enums_1.SizeAnimationStatus.decreasing;\n            } else {\n              particle.size.value += (particle.size.velocity || 0) * deltaFactor;\n            }\n\n            break;\n\n          case Enums_1.SizeAnimationStatus.decreasing:\n            if (particle.size.value <= sizeAnim.minimumValue) {\n              particle.size.status = Enums_1.SizeAnimationStatus.increasing;\n            } else {\n              particle.size.value -= (particle.size.velocity || 0) * deltaFactor;\n            }\n\n        }\n\n        switch (sizeAnim.destroy) {\n          case Enums_1.DestroyType.max:\n            if (particle.size.value >= sizeOpt.value * container.retina.pixelRatio) {\n              particle.destroy();\n            }\n\n            break;\n\n          case Enums_1.DestroyType.min:\n            if (particle.size.value <= sizeAnim.minimumValue * container.retina.pixelRatio) {\n              particle.destroy();\n            }\n\n            break;\n        }\n\n        if (particle.size.value < 0 && !particle.destroyed) {\n          particle.size.value = 0;\n        }\n      }\n    }\n  }, {\n    key: \"updateAngle\",\n    value: function updateAngle(delta) {\n      var options = this.container.options;\n      var particle = this.particle;\n      var deltaFactor = options.fpsLimit > 0 ? 60 * delta / 1000 : 3.6;\n\n      if (particle.particlesOptions.rotate.animation.enable) {\n        switch (particle.rotateDirection) {\n          case Enums_1.RotateDirection.clockwise:\n            particle.angle += particle.particlesOptions.rotate.animation.speed * Math.PI / 18 * deltaFactor;\n\n            if (particle.angle > 360) {\n              particle.angle -= 360;\n            }\n\n            break;\n\n          case Enums_1.RotateDirection.counterClockwise:\n          default:\n            particle.angle -= particle.particlesOptions.rotate.animation.speed * Math.PI / 18 * deltaFactor;\n\n            if (particle.angle < 0) {\n              particle.angle += 360;\n            }\n\n            break;\n        }\n      }\n    }\n  }, {\n    key: \"updateColor\",\n    value: function updateColor(delta) {\n      var options = this.container.options;\n      var particle = this.particle;\n\n      if (particle.color === undefined) {\n        return;\n      }\n\n      var deltaFactor = options.fpsLimit > 0 ? 60 * delta / 1000 : 3.6;\n\n      if (particle.particlesOptions.color.animation.enable) {\n        particle.color.h += (particle.colorVelocity || 0) * deltaFactor;\n\n        if (particle.color.h > 360) {\n          particle.color.h -= 360;\n        }\n      }\n    }\n  }, {\n    key: \"fixOutOfCanvasPosition\",\n    value: function fixOutOfCanvasPosition() {\n      var container = this.container;\n      var particle = this.particle;\n      var outMode = particle.particlesOptions.move.outMode;\n      var wrap = particle.particlesOptions.move.warp;\n      var canvasSize = container.canvas.size;\n      var newPos;\n\n      if (outMode === Enums_1.OutMode.bounce) {\n        newPos = {\n          bottom: canvasSize.height,\n          left: particle.size.value,\n          right: canvasSize.width,\n          top: particle.size.value\n        };\n      } else if (outMode === Enums_1.OutMode.bounceHorizontal) {\n        newPos = {\n          bottom: canvasSize.height + particle.size.value - particle.offset.y,\n          left: particle.size.value,\n          right: canvasSize.width,\n          top: -particle.size.value - particle.offset.y\n        };\n      } else if (outMode === Enums_1.OutMode.bounceVertical) {\n        newPos = {\n          bottom: canvasSize.height,\n          left: -particle.size.value - particle.offset.x,\n          right: canvasSize.width + particle.size.value + particle.offset.x,\n          top: particle.size.value\n        };\n      } else {\n        newPos = {\n          bottom: canvasSize.height + particle.size.value - particle.offset.y,\n          left: -particle.size.value - particle.offset.x,\n          right: canvasSize.width + particle.size.value + particle.offset.x,\n          top: -particle.size.value - particle.offset.y\n        };\n      }\n\n      if (outMode === Enums_1.OutMode.destroy) {\n        var sizeValue = particle.size.value;\n\n        if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, sizeValue)) {\n          container.particles.remove(particle);\n        }\n      } else {\n        var _sizeValue = particle.size.value;\n        var nextBounds = Utils_1.Utils.calculateBounds(particle.position, _sizeValue);\n\n        if (nextBounds.left > canvasSize.width - particle.offset.x) {\n          particle.position.x = newPos.left;\n\n          if (!wrap) {\n            particle.position.y = Math.random() * canvasSize.height;\n          }\n        } else if (nextBounds.right < -particle.offset.x) {\n          particle.position.x = newPos.right;\n\n          if (!wrap) {\n            particle.position.y = Math.random() * canvasSize.height;\n          }\n        }\n\n        if (nextBounds.top > canvasSize.height - particle.offset.y) {\n          if (!wrap) {\n            particle.position.x = Math.random() * canvasSize.width;\n          }\n\n          particle.position.y = newPos.top;\n        } else if (nextBounds.bottom < -particle.offset.y) {\n          if (!wrap) {\n            particle.position.x = Math.random() * canvasSize.width;\n          }\n\n          particle.position.y = newPos.bottom;\n        }\n      }\n    }\n  }, {\n    key: \"updateOutMode\",\n    value: function updateOutMode(delta) {\n      switch (this.particle.particlesOptions.move.outMode) {\n        case Enums_1.OutMode.bounce:\n        case Enums_1.OutMode.bounceVertical:\n        case Enums_1.OutMode.bounceHorizontal:\n          this.updateBounce(delta);\n          break;\n      }\n    }\n  }, {\n    key: \"updateBounce\",\n    value: function updateBounce(delta) {\n      var container = this.container;\n      var particle = this.particle;\n      var handled = false;\n\n      var _iterator = _createForOfIteratorHelper(container.plugins),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              plugin = _step$value[1];\n\n          if (plugin.particleBounce !== undefined) {\n            handled = plugin.particleBounce(particle, delta);\n          }\n\n          if (handled) {\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (!handled) {\n        var outMode = particle.particlesOptions.move.outMode;\n        var pos = particle.getPosition();\n\n        if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceHorizontal) {\n          var size = particle.size.value;\n          var velocity = particle.velocity.horizontal;\n          Updater.checkBounds(pos.x, size, container.canvas.size.width, velocity, function () {\n            particle.velocity.horizontal *= -1;\n          });\n        }\n\n        if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceVertical) {\n          var _size = particle.size.value;\n          var _velocity = particle.velocity.vertical;\n          Updater.checkBounds(pos.y, _size, container.canvas.size.height, _velocity, function () {\n            particle.velocity.vertical *= -1;\n          });\n        }\n      }\n    }\n  }], [{\n    key: \"checkBounds\",\n    value: function checkBounds(coordinate, radius, size, velocity, outside) {\n      if (coordinate + radius > size && velocity > 0 || coordinate - radius < 0 && velocity < 0) {\n        outside();\n      }\n    }\n  }]);\n\n  return Updater;\n}();\n\nexports.Updater = Updater;","map":{"version":3,"sources":["C:/Users/User/WebstormProjects/personal-React_JS-Website/node_modules/tsparticles/dist/Core/Particle/Updater.js"],"names":["Object","defineProperty","exports","value","Updater","Utils_1","require","Mover_1","Enums_1","container","particle","mover","Mover","delta","move","updateOpacity","updateSize","updateAngle","updateColor","fixOutOfCanvasPosition","updateOutMode","options","deltaFactor","fpsLimit","particlesOptions","opacity","animation","enable","status","OpacityAnimationStatus","increasing","decreasing","velocity","minimumValue","_a","sizeOpt","size","sizeAnim","SizeAnimationStatus","sizeValue","retina","destroy","DestroyType","max","pixelRatio","min","destroyed","rotate","rotateDirection","RotateDirection","clockwise","angle","speed","Math","PI","counterClockwise","color","undefined","h","colorVelocity","outMode","wrap","warp","canvasSize","canvas","newPos","OutMode","bounce","bottom","height","left","right","width","top","bounceHorizontal","offset","y","bounceVertical","x","Utils","isPointInside","position","particles","remove","nextBounds","calculateBounds","random","updateBounce","handled","plugins","plugin","particleBounce","pos","getPosition","horizontal","checkBounds","vertical","coordinate","radius","outside"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Updater = void 0;\nconst Utils_1 = require(\"../../Utils\");\nconst Mover_1 = require(\"./Mover\");\nconst Enums_1 = require(\"../../Enums\");\nclass Updater {\n    constructor(container, particle) {\n        this.container = container;\n        this.particle = particle;\n        this.mover = new Mover_1.Mover(container, particle);\n    }\n    static checkBounds(coordinate, radius, size, velocity, outside) {\n        if ((coordinate + radius > size && velocity > 0) || (coordinate - radius < 0 && velocity < 0)) {\n            outside();\n        }\n    }\n    update(delta) {\n        this.mover.move(delta);\n        this.updateOpacity(delta);\n        this.updateSize(delta);\n        this.updateAngle(delta);\n        this.updateColor(delta);\n        this.fixOutOfCanvasPosition();\n        this.updateOutMode(delta);\n    }\n    updateOpacity(delta) {\n        const options = this.container.options;\n        const particle = this.particle;\n        const deltaFactor = options.fpsLimit > 0 ? (60 * delta) / 1000 : 3.6;\n        if (particle.particlesOptions.opacity.animation.enable) {\n            switch (particle.opacity.status) {\n                case Enums_1.OpacityAnimationStatus.increasing:\n                    if (particle.opacity.value >= particle.particlesOptions.opacity.value) {\n                        particle.opacity.status = Enums_1.OpacityAnimationStatus.decreasing;\n                    }\n                    else {\n                        particle.opacity.value += (particle.opacity.velocity || 0) * deltaFactor;\n                    }\n                    break;\n                case Enums_1.OpacityAnimationStatus.decreasing:\n                    if (particle.opacity.value <= particle.particlesOptions.opacity.animation.minimumValue) {\n                        particle.opacity.status = Enums_1.OpacityAnimationStatus.increasing;\n                    }\n                    else {\n                        particle.opacity.value -= (particle.opacity.velocity || 0) * deltaFactor;\n                    }\n                    break;\n            }\n            if (particle.opacity.value < 0) {\n                particle.opacity.value = 0;\n            }\n        }\n    }\n    updateSize(delta) {\n        var _a;\n        const container = this.container;\n        const options = container.options;\n        const particle = this.particle;\n        const deltaFactor = options.fpsLimit > 0 ? (60 * delta) / 1000 : 3.6;\n        const sizeOpt = particle.particlesOptions.size;\n        const sizeAnim = sizeOpt.animation;\n        if (sizeAnim.enable) {\n            switch (particle.size.status) {\n                case Enums_1.SizeAnimationStatus.increasing:\n                    if (particle.size.value >= ((_a = particle.sizeValue) !== null && _a !== void 0 ? _a : container.retina.sizeValue)) {\n                        particle.size.status = Enums_1.SizeAnimationStatus.decreasing;\n                    }\n                    else {\n                        particle.size.value += (particle.size.velocity || 0) * deltaFactor;\n                    }\n                    break;\n                case Enums_1.SizeAnimationStatus.decreasing:\n                    if (particle.size.value <= sizeAnim.minimumValue) {\n                        particle.size.status = Enums_1.SizeAnimationStatus.increasing;\n                    }\n                    else {\n                        particle.size.value -= (particle.size.velocity || 0) * deltaFactor;\n                    }\n            }\n            switch (sizeAnim.destroy) {\n                case Enums_1.DestroyType.max:\n                    if (particle.size.value >= sizeOpt.value * container.retina.pixelRatio) {\n                        particle.destroy();\n                    }\n                    break;\n                case Enums_1.DestroyType.min:\n                    if (particle.size.value <= sizeAnim.minimumValue * container.retina.pixelRatio) {\n                        particle.destroy();\n                    }\n                    break;\n            }\n            if (particle.size.value < 0 && !particle.destroyed) {\n                particle.size.value = 0;\n            }\n        }\n    }\n    updateAngle(delta) {\n        const options = this.container.options;\n        const particle = this.particle;\n        const deltaFactor = options.fpsLimit > 0 ? (60 * delta) / 1000 : 3.6;\n        if (particle.particlesOptions.rotate.animation.enable) {\n            switch (particle.rotateDirection) {\n                case Enums_1.RotateDirection.clockwise:\n                    particle.angle += ((particle.particlesOptions.rotate.animation.speed * Math.PI) / 18) * deltaFactor;\n                    if (particle.angle > 360) {\n                        particle.angle -= 360;\n                    }\n                    break;\n                case Enums_1.RotateDirection.counterClockwise:\n                default:\n                    particle.angle -= ((particle.particlesOptions.rotate.animation.speed * Math.PI) / 18) * deltaFactor;\n                    if (particle.angle < 0) {\n                        particle.angle += 360;\n                    }\n                    break;\n            }\n        }\n    }\n    updateColor(delta) {\n        const options = this.container.options;\n        const particle = this.particle;\n        if (particle.color === undefined) {\n            return;\n        }\n        const deltaFactor = options.fpsLimit > 0 ? (60 * delta) / 1000 : 3.6;\n        if (particle.particlesOptions.color.animation.enable) {\n            particle.color.h += (particle.colorVelocity || 0) * deltaFactor;\n            if (particle.color.h > 360) {\n                particle.color.h -= 360;\n            }\n        }\n    }\n    fixOutOfCanvasPosition() {\n        const container = this.container;\n        const particle = this.particle;\n        const outMode = particle.particlesOptions.move.outMode;\n        const wrap = particle.particlesOptions.move.warp;\n        const canvasSize = container.canvas.size;\n        let newPos;\n        if (outMode === Enums_1.OutMode.bounce) {\n            newPos = {\n                bottom: canvasSize.height,\n                left: particle.size.value,\n                right: canvasSize.width,\n                top: particle.size.value,\n            };\n        }\n        else if (outMode === Enums_1.OutMode.bounceHorizontal) {\n            newPos = {\n                bottom: canvasSize.height + particle.size.value - particle.offset.y,\n                left: particle.size.value,\n                right: canvasSize.width,\n                top: -particle.size.value - particle.offset.y,\n            };\n        }\n        else if (outMode === Enums_1.OutMode.bounceVertical) {\n            newPos = {\n                bottom: canvasSize.height,\n                left: -particle.size.value - particle.offset.x,\n                right: canvasSize.width + particle.size.value + particle.offset.x,\n                top: particle.size.value,\n            };\n        }\n        else {\n            newPos = {\n                bottom: canvasSize.height + particle.size.value - particle.offset.y,\n                left: -particle.size.value - particle.offset.x,\n                right: canvasSize.width + particle.size.value + particle.offset.x,\n                top: -particle.size.value - particle.offset.y,\n            };\n        }\n        if (outMode === Enums_1.OutMode.destroy) {\n            const sizeValue = particle.size.value;\n            if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, sizeValue)) {\n                container.particles.remove(particle);\n            }\n        }\n        else {\n            const sizeValue = particle.size.value;\n            const nextBounds = Utils_1.Utils.calculateBounds(particle.position, sizeValue);\n            if (nextBounds.left > canvasSize.width - particle.offset.x) {\n                particle.position.x = newPos.left;\n                if (!wrap) {\n                    particle.position.y = Math.random() * canvasSize.height;\n                }\n            }\n            else if (nextBounds.right < -particle.offset.x) {\n                particle.position.x = newPos.right;\n                if (!wrap) {\n                    particle.position.y = Math.random() * canvasSize.height;\n                }\n            }\n            if (nextBounds.top > canvasSize.height - particle.offset.y) {\n                if (!wrap) {\n                    particle.position.x = Math.random() * canvasSize.width;\n                }\n                particle.position.y = newPos.top;\n            }\n            else if (nextBounds.bottom < -particle.offset.y) {\n                if (!wrap) {\n                    particle.position.x = Math.random() * canvasSize.width;\n                }\n                particle.position.y = newPos.bottom;\n            }\n        }\n    }\n    updateOutMode(delta) {\n        switch (this.particle.particlesOptions.move.outMode) {\n            case Enums_1.OutMode.bounce:\n            case Enums_1.OutMode.bounceVertical:\n            case Enums_1.OutMode.bounceHorizontal:\n                this.updateBounce(delta);\n                break;\n        }\n    }\n    updateBounce(delta) {\n        const container = this.container;\n        const particle = this.particle;\n        let handled = false;\n        for (const [, plugin] of container.plugins) {\n            if (plugin.particleBounce !== undefined) {\n                handled = plugin.particleBounce(particle, delta);\n            }\n            if (handled) {\n                break;\n            }\n        }\n        if (!handled) {\n            const outMode = particle.particlesOptions.move.outMode;\n            const pos = particle.getPosition();\n            if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceHorizontal) {\n                const size = particle.size.value;\n                const velocity = particle.velocity.horizontal;\n                Updater.checkBounds(pos.x, size, container.canvas.size.width, velocity, () => {\n                    particle.velocity.horizontal *= -1;\n                });\n            }\n            if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceVertical) {\n                const size = particle.size.value;\n                const velocity = particle.velocity.vertical;\n                Updater.checkBounds(pos.y, size, container.canvas.size.height, velocity, () => {\n                    particle.velocity.vertical *= -1;\n                });\n            }\n        }\n    }\n}\nexports.Updater = Updater;\n"]},"metadata":{},"sourceType":"script"}